/**
 * Vibe Message Handler
 * Processes AI responses from workforce orchestrator and extracts code files
 *
 * Created: Nov 18th 2025
 */

import { vibeFileSystem } from '@features/mission-control/services/vibe-file-system';
import { toast } from 'sonner';

export interface ExtractedFile {
  path: string;
  content: string;
  language: string;
}

export interface CodeBlock {
  language: string;
  filePath?: string;
  content: string;
}

/**
 * Parse code blocks from markdown response
 * Supports formats:
 * - ```tsx:src/App.tsx
 * - ```typescript // src/App.tsx
 * - ```js (no file path)
 */
export function parseCodeBlocks(markdown: string): CodeBlock[] {
  const codeBlocks: CodeBlock[] = [];

  // Regex to match code fences with optional file path
  // Formats: ```lang:path, ```lang // path, ```lang
  const codeBlockRegex = /```(\w+)(?::([^\n]+)|(?:\s*\/\/\s*([^\n]+))?)?\n([\s\S]*?)```/g;

  let match;
  while ((match = codeBlockRegex.exec(markdown)) !== null) {
    const [, language, colonPath, commentPath, content] = match;
    const filePath = colonPath?.trim() || commentPath?.trim();

    codeBlocks.push({
      language: language || 'plaintext',
      filePath: filePath || undefined,
      content: content.trim(),
    });
  }

  return codeBlocks;
}

/**
 * Extract files from code blocks
 * Only returns blocks that have explicit file paths
 */
export function extractFilesFromCodeBlocks(codeBlocks: CodeBlock[]): ExtractedFile[] {
  const files: ExtractedFile[] = [];

  for (const block of codeBlocks) {
    if (block.filePath) {
      files.push({
        path: normalizeFilePath(block.filePath),
        content: block.content,
        language: mapLanguageToMonaco(block.language),
      });
    }
  }

  return files;
}

/**
 * Normalize file path (remove leading ./ and ensure no starting /)
 */
function normalizeFilePath(path: string): string {
  let normalized = path.trim();

  // Remove leading ./
  if (normalized.startsWith('./')) {
    normalized = normalized.slice(2);
  }

  // Remove leading /
  if (normalized.startsWith('/')) {
    normalized = normalized.slice(1);
  }

  return normalized;
}

/**
 * Map code fence language to Monaco editor language
 */
function mapLanguageToMonaco(language: string): string {
  const languageMap: Record<string, string> = {
    tsx: 'typescript',
    ts: 'typescript',
    jsx: 'javascript',
    js: 'javascript',
    py: 'python',
    html: 'html',
    css: 'css',
    scss: 'scss',
    sass: 'scss',
    json: 'json',
    md: 'markdown',
    markdown: 'markdown',
    yaml: 'yaml',
    yml: 'yaml',
    xml: 'xml',
    sql: 'sql',
    sh: 'shell',
    bash: 'shell',
    go: 'go',
    rust: 'rust',
    rs: 'rust',
    java: 'java',
    cpp: 'cpp',
    c: 'c',
    php: 'php',
    rb: 'ruby',
    ruby: 'ruby',
    swift: 'swift',
    kotlin: 'kotlin',
    vue: 'vue',
    svelte: 'svelte',
  };

  return languageMap[language.toLowerCase()] || 'plaintext';
}

/**
 * Create files in vibeFileSystem
 */
export function createFilesInFileSystem(files: ExtractedFile[]): number {
  let created = 0;

  for (const file of files) {
    try {
      // Normalize path (vibeFileSystem expects leading /)
      const normalizedPath = file.path.startsWith('/') ? file.path : `/${file.path}`;

      // Check if file exists
      try {
        vibeFileSystem.readFile(normalizedPath);
        // File exists, update it
        vibeFileSystem.updateFile(normalizedPath, file.content);
        console.log(`[VIBE] Updated file: ${normalizedPath}`);
      } catch {
        // File doesn't exist, create it
        vibeFileSystem.createFile(normalizedPath, file.content);
        console.log(`[VIBE] Created file: ${normalizedPath}`);
      }

      created++;
    } catch (error) {
      console.error(`[VIBE] Failed to create file ${file.path}:`, error);
    }
  }

  return created;
}

/**
 * Detect project structure from file paths
 * Returns project type and suggested preview URL
 */
export function detectProjectStructure(files: ExtractedFile[]): {
  type: 'react' | 'html' | 'node' | 'unknown';
  entryPoint: string | null;
  suggestedPreviewUrl: string | null;
} {
  const paths = files.map(f => f.path);

  // Check for React project
  const hasReactFiles = paths.some(p =>
    p.includes('App.tsx') ||
    p.includes('App.jsx') ||
    p.includes('index.tsx') ||
    p.includes('main.tsx')
  );

  if (hasReactFiles) {
    return {
      type: 'react',
      entryPoint: paths.find(p => p.includes('index.html')) || paths.find(p => p.includes('App')) || null,
      suggestedPreviewUrl: null, // Will be generated by bundler
    };
  }

  // Check for standalone HTML
  const htmlFile = paths.find(p => p.endsWith('.html'));
  if (htmlFile) {
    return {
      type: 'html',
      entryPoint: htmlFile,
      suggestedPreviewUrl: null, // Will use blob URL
    };
  }

  // Check for Node.js/backend
  const hasServerFiles = paths.some(p =>
    p.includes('server.') ||
    p.includes('index.js') ||
    p.includes('app.js')
  );

  if (hasServerFiles) {
    return {
      type: 'node',
      entryPoint: paths.find(p => p.includes('server.') || p.includes('index.js')) || null,
      suggestedPreviewUrl: null, // Can't preview server-side
    };
  }

  return {
    type: 'unknown',
    entryPoint: null,
    suggestedPreviewUrl: null,
  };
}

/**
 * Process AI response and create files in the vibe file system
 */
export async function processAIResponse(
  response: string,
  sessionId: string
): Promise<{
  filesCreated: number;
  files: ExtractedFile[];
  projectInfo: ReturnType<typeof detectProjectStructure>;
}> {
  // Parse code blocks from response
  const codeBlocks = parseCodeBlocks(response);

  if (codeBlocks.length === 0) {
    console.log('[VIBE] No code blocks found in AI response');
    return {
      filesCreated: 0,
      files: [],
      projectInfo: { type: 'unknown', entryPoint: null, suggestedPreviewUrl: null },
    };
  }

  // Extract files (only blocks with file paths)
  const files = extractFilesFromCodeBlocks(codeBlocks);

  if (files.length === 0) {
    console.log('[VIBE] No files with paths found in code blocks');
    toast.info('AI generated code but didn\'t specify file paths. Please ask for specific file names.');
    return {
      filesCreated: 0,
      files: [],
      projectInfo: { type: 'unknown', entryPoint: null, suggestedPreviewUrl: null },
    };
  }

  console.log(`[VIBE] Extracted ${files.length} files from AI response`);

  // Create files in file system
  const filesCreated = createFilesInFileSystem(files);

  // Detect project structure
  const projectInfo = detectProjectStructure(files);

  // Auto-open first file if any were created
  if (filesCreated > 0 && files.length > 0) {
    try {
      const firstPath = files[0].path.startsWith('/') ? files[0].path : `/${files[0].path}`;
      vibeFileSystem.openFile(firstPath);
    } catch (error) {
      console.error('[VIBE] Failed to auto-open first file:', error);
    }
  }

  toast.success(`Created ${filesCreated} file${filesCreated > 1 ? 's' : ''}`);

  return {
    filesCreated,
    files,
    projectInfo,
  };
}

/**
 * Check if response contains code that should be extracted
 */
export function hasExtractableCode(response: string): boolean {
  const codeBlocks = parseCodeBlocks(response);
  const filesWithPaths = codeBlocks.filter(block => block.filePath);
  return filesWithPaths.length > 0;
}

/**
 * Vibe Message Handler Service
 * Main service class for processing AI responses
 */
export class VibeMessageHandler {
  async handleAIResponse(response: string, sessionId: string) {
    return await processAIResponse(response, sessionId);
  }

  parseCodeBlocks(markdown: string) {
    return parseCodeBlocks(markdown);
  }

  extractFiles(markdown: string) {
    const blocks = parseCodeBlocks(markdown);
    return extractFilesFromCodeBlocks(blocks);
  }

  hasExtractableCode(response: string) {
    return hasExtractableCode(response);
  }
}

// Export singleton instance
export const vibeMessageHandler = new VibeMessageHandler();
